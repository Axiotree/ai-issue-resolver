name: Release on Version Change

on:
  push:
    branches:
      - main
      
permissions:
  contents: write

jobs:
  release_on_version_change:
    runs-on: ubuntu-latest

    steps:
      - name: Check out code
        uses: actions/checkout@v3
        with:
          # Ensure we fetch the full commit history so HEAD^ exists
          fetch-depth: 0

      - name: Compare version
        id: compare_version
        run: |
          # Get the latest tag from GitHub
          LATEST_TAG=$(git describe --tags `git rev-list --tags --max-count=1`)

          # Read the new version field from package.json
          NEW_VERSION=$(jq -r '.version' package.json)

          echo "LATEST_TAG=$LATEST_TAG" >> $GITHUB_OUTPUT
          echo "NEW_VERSION=$NEW_VERSION" >> $GITHUB_OUTPUT

          if [ "v$NEW_VERSION" != "$LATEST_TAG" ]; then
            echo "version_changed=true" >> $GITHUB_OUTPUT
          else
            echo "version_changed=false" >> $GITHUB_OUTPUT
          fi

      - name: Generate release notes
        id: generate_notes
        if: steps.compare_version.outputs.version_changed == 'true'
        run: |
          OLD_VERSION=${{ steps.compare_version.outputs.OLD_VERSION }}
          NEW_VERSION=${{ steps.compare_version.outputs.NEW_VERSION }}

          # If OLD_VERSION is null or empty, we just grab the latest commit message
          if [ -z "$OLD_VERSION" ] || [ "$OLD_VERSION" = "null" ]; then
            NOTES=$(git log -1 --pretty=format:"- %s" --no-merges)
          else
            # You can refine how you calculate the range here
            # For simplicity, we log from OLD_VERSION..HEAD if there's a tag named v<OLD_VERSION>
            if git rev-parse "v$OLD_VERSION" >/dev/null 2>&1; then
              RANGE="v$OLD_VERSION..HEAD"
            else
              RANGE="HEAD^..HEAD"
            fi
            NOTES=$(git log $RANGE --pretty=format:"- %s" --no-merges)
          fi

          # Output the notes to be used by the next step
          echo "notes<<EOF" >> $GITHUB_OUTPUT
          echo "$NOTES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Set up Git remote
        run: |
            git remote set-url origin https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }} 
              
      - name: Push tag
        if: steps.compare_version.outputs.version_changed == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
            NEW_VERSION=${{ steps.compare_version.outputs.NEW_VERSION }}
            git tag "v$NEW_VERSION"
            git push origin "v$NEW_VERSION"

      - name: Create GitHub Release
        if: steps.compare_version.outputs.version_changed == 'true'
        uses: actions/create-release@v1
        with:
          tag_name: v${{ steps.compare_version.outputs.NEW_VERSION }}
          release_name: Release v${{ steps.compare_version.outputs.NEW_VERSION }}
          body: ${{ steps.generate_notes.outputs.notes }}
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}