name: Release on Version Change

on:
  push:
    branches:
      - main

jobs:
  release_on_version_change:
    runs-on: ubuntu-latest

    steps:
      - name: Check out code
        uses: actions/checkout@v3
        with:
            fetch-depth: 0  # Fetch all history so HEAD^ exists
      - name: Detect if package.json changed
        id: detect_change
        run: |
          PACKAGE_JSON_CHANGED=$(git diff --name-only HEAD^ HEAD | grep "package.json" || true)
          if [ -z "$PACKAGE_JSON_CHANGED" ]; then
            echo "changed=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          echo "changed=true" >> $GITHUB_OUTPUT

      - name: Compare version
        id: compare_version
        if: steps.detect_change.outputs.changed == 'true'
        run: |
          OLD_VERSION=$(git show HEAD^:package.json | jq -r '.version')
          NEW_VERSION=$(jq -r '.version' package.json)

          echo "OLD_VERSION=$OLD_VERSION" >> $GITHUB_OUTPUT
          echo "NEW_VERSION=$NEW_VERSION" >> $GITHUB_OUTPUT

          if [ "$OLD_VERSION" != "$NEW_VERSION" ]; then
            echo "version_changed=true" >> $GITHUB_OUTPUT
          else
            echo "version_changed=false" >> $GITHUB_OUTPUT

      - name: Generate release notes
        id: generate_notes
        if: steps.compare_version.outputs.version_changed == 'true'
        run: |
          # Collect all commit messages from the previous tag (if any) to HEAD.
          # If there's no previous tag, this might error or produce no notes.
          # Feel free to refine how you detect the "old tag" if needed.
          # For simplicity, we assume the old tag was "v$OLD_VERSION".
          OLD_VERSION=${{ steps.compare_version.outputs.OLD_VERSION }}
          NEW_VERSION=${{ steps.compare_version.outputs.NEW_VERSION }}

          # If OLD_VERSION is empty, fallback to HEAD^..HEAD
          if [ -z "$OLD_VERSION" ] || [ "$OLD_VERSION" = "null" ]; then
            NOTES=$(git log -1 --pretty=format:"- %s" --no-merges)
          else
            if git rev-parse "v$OLD_VERSION" >/dev/null 2>&1; then
              RANGE="v$OLD_VERSION..HEAD"
            else
              RANGE="HEAD^..HEAD"
            fi
            NOTES=$(git log $RANGE --pretty=format:"- %s" --no-merges)
          fi

          # Output to the next step
          echo "notes<<EOF" >> $GITHUB_OUTPUT
          echo "$NOTES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create Git tag
        if: steps.compare_version.outputs.version_changed == 'true'
        run: |
          NEW_VERSION=${{ steps.compare_version.outputs.NEW_VERSION }}
          git config user.name "github-actions"
          git config user.email "github-actions@github.com"
          git tag "v$NEW_VERSION"
          git push origin "v$NEW_VERSION"

      - name: Create GitHub Release
        if: steps.compare_version.outputs.version_changed == 'true'
        uses: actions/create-release@v1
        with:
          tag_name: v${{ steps.compare_version.outputs.NEW_VERSION }}
          release_name: Release v${{ steps.compare_version.outputs.NEW_VERSION }}
          body: ${{ steps.generate_notes.outputs.notes }}
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}