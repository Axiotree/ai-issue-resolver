name: Release on Version Change

on:
  push:
    branches:
      - main

jobs:
  release_on_version_change:
    runs-on: ubuntu-latest

    steps:
      - name: Check out code
        uses: actions/checkout@v3
        with:
          # Ensure we fetch the full commit history so HEAD^ exists
          fetch-depth: 0

      - name: Detect if package.json changed
        id: detect_change
        run: |
          # Check if package.json is in the list of changed files in the latest commit
          PACKAGE_JSON_CHANGED=$(git diff --name-only HEAD^ HEAD | grep "package.json" || true)
          if [ -z "$PACKAGE_JSON_CHANGED" ]; then
            echo "changed=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          echo "changed=true" >> $GITHUB_OUTPUT

      - name: Compare version
        id: compare_version
        if: steps.detect_change.outputs.changed == 'true'
        run: |
          # Verify that HEAD^ exists (in case there's only one commit)
          if ! git show HEAD^:package.json >/dev/null 2>&1; then
            echo "No previous commit found. Skipping version check."
            echo "version_changed=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Read old vs. new version fields from package.json
          OLD_VERSION=$(git show HEAD^:package.json | jq -r '.version')
          NEW_VERSION=$(jq -r '.version' package.json)

          echo "OLD_VERSION=$OLD_VERSION" >> $GITHUB_OUTPUT
          echo "NEW_VERSION=$NEW_VERSION" >> $GITHUB_OUTPUT

          if [ "$OLD_VERSION" != "$NEW_VERSION" ]; then
            echo "version_changed=true" >> $GITHUB_OUTPUT
          else
            echo "version_changed=false" >> $GITHUB_OUTPUT
          fi

      - name: Generate release notes
        id: generate_notes
        if: steps.compare_version.outputs.version_changed == 'true'
        run: |
          OLD_VERSION=${{ steps.compare_version.outputs.OLD_VERSION }}
          NEW_VERSION=${{ steps.compare_version.outputs.NEW_VERSION }}

          # If OLD_VERSION is null or empty, we just grab the latest commit message
          if [ -z "$OLD_VERSION" ] || [ "$OLD_VERSION" = "null" ]; then
            NOTES=$(git log -1 --pretty=format:"- %s" --no-merges)
          else
            # You can refine how you calculate the range here
            # For simplicity, we log from OLD_VERSION..HEAD if there's a tag named v<OLD_VERSION>
            if git rev-parse "v$OLD_VERSION" >/dev/null 2>&1; then
              RANGE="v$OLD_VERSION..HEAD"
            else
              RANGE="HEAD^..HEAD"
            fi
            NOTES=$(git log $RANGE --pretty=format:"- %s" --no-merges)
          fi

          # Output the notes to be used by the next step
          echo "notes<<EOF" >> $GITHUB_OUTPUT
          echo "$NOTES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create Git tag
        if: steps.compare_version.outputs.version_changed == 'true'
        run: |
          NEW_VERSION=${{ steps.compare_version.outputs.NEW_VERSION }}
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          # Tag the new version
          git tag "v$NEW_VERSION"
          # Push the new tag
          git push origin "v$NEW_VERSION"

      - name: Create GitHub Release
        if: steps.compare_version.outputs.version_changed == 'true'
        uses: actions/create-release@v1
        with:
          tag_name: v${{ steps.compare_version.outputs.NEW_VERSION }}
          release_name: Release v${{ steps.compare_version.outputs.NEW_VERSION }}
          body: ${{ steps.generate_notes.outputs.notes }}
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}